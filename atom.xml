<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://miexxx.github.io</id>
    <title>Great Wei</title>
    <updated>2020-05-11T03:33:36.997Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://miexxx.github.io"/>
    <link rel="self" href="https://miexxx.github.io/atom.xml"/>
    <subtitle>awsl</subtitle>
    <logo>https://miexxx.github.io/images/avatar.png</logo>
    <icon>https://miexxx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Great Wei</rights>
    <entry>
        <title type="html"><![CDATA[Http]]></title>
        <id>https://miexxx.github.io/post/http/</id>
        <link href="https://miexxx.github.io/post/http/">
        </link>
        <updated>2020-04-28T06:49:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="基础概念">基础概念</h1>
<h2 id="uri">uri</h2>
<p>uri包好url 和urn<br>
<img src="https://camo.githubusercontent.com/b61eb498c8b9458916441d9341d3975b6e1134cf/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38343431623263342d646361372d346436622d386566622d6632326566636361663333312e706e67" alt="" loading="lazy"></p>
<h2 id="请求和响应报文">请求和响应报文</h2>
<h3 id="请求报文">请求报文</h3>
<figure data-type="image" tabindex="1"><img src="https://camo.githubusercontent.com/f48540e5efe054841d1aa19097666c4b35500c10/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f485454505f526571756573744d6573736167654578616d706c652e706e67" alt="" loading="lazy"></figure>
<h3 id="响应报文">响应报文</h3>
<figure data-type="image" tabindex="2"><img src="https://camo.githubusercontent.com/6ee5dc048dd39a9c4f9a180cee34c66b196a7c45/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f485454505f526573706f6e73654d6573736167654578616d706c652e706e67" alt="" loading="lazy"></figure>
<h3 id="get">GET</h3>
<p>获取资源<br>
当前网络请求中，绝大部分使用的是GET方法。</p>
<h3 id="head">HEAD</h3>
<p>获取报文首部<br>
和GET方法类似，但是不返回报文实体主体部分。<br>
主要用于确认URL的有效性以及资源更新的日期时间等。</p>
<h3 id="post">POST</h3>
<p>传输实体主体<br>
POST主要用来传输数据，而GET主要用来获取资源。</p>
<h3 id="put">PUT</h3>
<p>上传文件<br>
由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p>
<h3 id="patch">PATCH</h3>
<p>对资源进行部分修改<br>
PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p>
<h3 id="delete">DELETE</h3>
<p>删除文件<br>
与PUT功能相反，并且同样不带验证机制。</p>
<h3 id="options">OPTIONS</h3>
<p>查询支持的方法<br>
查询指定URL能够支持的方法</p>
<h3 id="connect">CONNECT</h3>
<p>要求在与代理服务器通信时简历隧道<br>
使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。<br>
CONNECT www.example.com:443 HTTP/1.1</p>
<h3 id="trace">TRACE</h3>
<p>服务器会将通信路径返回给客户端。<br>
发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。<br>
通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p>
<h2 id="http状态码">HTTP状态码</h2>
<p>服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>
<h3 id="1xx信息">1xx信息</h3>
<p>100 Continue:表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p>
<h3 id="2xx成功">2xx成功</h3>
<p>200 ok<br>
204 No Content :请求已经成功处理，但是响应报文不包含实体的主题部分。<br>
一般只需要从客户端往服务器发送信息，而不逊要返回数据时使用。<br>
206 Partial Content：表示客户端进行了范围请求，响应报文报文包含 Content-Range 指定范围的实体内容。</p>
<h3 id="3xx重定向">3xx重定向</h3>
<p>301 Moved Permanmently : 永久重定向<br>
302 Found : 临时性重定向<br>
303 See Other： 和302有着相同的功能，但是303明确客户端应该采用GET方法获取资源<br>
304 Not Modified: 如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。<br>
307 Temporary Redirect: 临时重定向, 与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p>
<h3 id="4xx-客户端错误">4xx 客户端错误</h3>
<p>400 Bad Request ：请求报文中存在语法错误。<br>
401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。<br>
403 Forbidden ：请求被拒绝。<br>
404 Not Found</p>
<h3 id="5xx-服务端错误">5xx 服务端错误</h3>
<p>500 Internal Server Error ：服务器正在执行请求时发生错误。</p>
<p>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
<h2 id="http首部">HTTP首部</h2>
<h3 id="实体首部">实体首部</h3>
<h3 id="请求首部">请求首部</h3>
<h3 id="响应首部">响应首部</h3>
<h2 id="具体应用">具体应用</h2>
<h3 id="连接管理">连接管理</h3>
<h4 id="短连接与长连接">短连接与长连接</h4>
<p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p>
<p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p>
<p>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close；<br>
在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。</p>
<h4 id="流水线">流水线</h4>
<p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。<br>
流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p>
<h4 id="cookie">cookie</h4>
<p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p>
<h5 id="用途">用途</h5>
<p>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）<br>
个性化设置（如用户自定义设置、主题等）<br>
浏览器行为跟踪（如跟踪分析用户行为等）</p>
<h5 id="创建过程">创建过程</h5>
<p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p>
<p>HTTP/1.0 200 OK<br>
Content-type: text/html<br>
Set-Cookie: yummy_cookie=choco<br>
Set-Cookie: tasty_cookie=strawberry</p>
<p>[page content]<br>
客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p>
<p>GET /sample_page.html HTTP/1.1<br>
Host: www.example.org<br>
Cookie: yummy_cookie=choco; tasty_cookie=strawberry</p>
<h5 id="分类">分类</h5>
<p>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。<br>
持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。<br>
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</p>
<h5 id="作用域">作用域</h5>
<p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p>
<p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (&quot;/&quot;) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p>
<p>/docs<br>
/docs/Web/<br>
/docs/Web/HTTP</p>
<h5 id="javascript">JavaScript</h5>
<p>浏览器通过 document.cookie 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p>
<p>document.cookie = &quot;yummy_cookie=choco&quot;;<br>
document.cookie = &quot;tasty_cookie=strawberry&quot;;<br>
console.log(document.cookie);</p>
<h5 id="httponly">HttpOnly</h5>
<p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 document.cookie API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p>
<p>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</p>
<h5 id="secure">Secure</h5>
<p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p>
<h5 id="session">Session</h5>
<p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<p>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；<br>
服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；<br>
服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；<br>
客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。<br>
应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<h5 id="浏览器禁用cookie">浏览器禁用Cookie</h5>
<p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p>
<h5 id="cookie-与-session-选择">Cookie 与 Session 选择</h5>
<p>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；<br>
Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；<br>
对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</p>
<h2 id="缓存">缓存</h2>
<h3 id="优点">优点</h3>
<p>缓解服务器压力；<br>
降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</p>
<h3 id="实现方法">实现方法</h3>
<p>让代理服务器进行缓存；<br>
让客户端浏览器进行缓存。</p>
<h3 id="cache-control">Cache-Control</h3>
<p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p>
<h4 id="禁止进行缓存">禁止进行缓存</h4>
<p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。<br>
Cache-Control: no-store</p>
<h4 id="强制确认缓存">强制确认缓存</h4>
<p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p>
<p>Cache-Control: no-cache</p>
<h4 id="私有缓存和公共缓存">私有缓存和公共缓存</h4>
<p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p>
<p>Cache-Control: private<br>
public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p>
<p>Cache-Control: public</p>
<h4 id="缓存过期机制">缓存过期机制</h4>
<p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p>
<p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p>
<p>Cache-Control: max-age=31536000<br>
Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>
<p>Expires: Wed, 04 Jul 2012 08:26:05 GMT<br>
在 HTTP/1.1 中，会优先处理 max-age 指令；<br>
在 HTTP/1.0 中，max-age 指令会被忽略掉。</p>
<h4 id="缓存验真">缓存验真</h4>
<p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 http://www.google.com/ 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p>
<p>ETag: &quot;82e22293907ce725faf67773957acd12&quot;<br>
可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p>
<p>If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot;<br>
Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p>
<p>Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT<br>
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</p>
<h2 id="内部协商">内部协商</h2>
<p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Crontab]]></title>
        <id>https://miexxx.github.io/post/cr/</id>
        <link href="https://miexxx.github.io/post/cr/">
        </link>
        <updated>2020-04-23T12:36:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题">问题：</h2>
<p>crontab设置定时任务时，* * * * * php 1.php， 找不到php环境变量，导致任务执行失败。</p>
<p>解决方法：输入完整php路径。 * * * * * /usr/local/php 1.php</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux]]></title>
        <id>https://miexxx.github.io/post/linux/</id>
        <link href="https://miexxx.github.io/post/linux/">
        </link>
        <updated>2020-04-07T12:59:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="sync">sync</h2>
<p>为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘，因此关机之前需要先进行 sync 同步操作。</p>
<h2 id="path">PATH</h2>
<p>可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。</p>
<pre><code>/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
</code></pre>
<h2 id="磁盘的文件名">磁盘的文件名</h2>
<p>Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下：<br>
IDE 磁盘：/dev/hd[a-d]<br>
SATA/SCSI/SAS 磁盘：/dev/sd[a-p]<br>
其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。</p>
<h2 id="分区">分区</h2>
<p>磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。</p>
<h3 id="mbr">MBR</h3>
<p>MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。<br>
分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区来记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。<br>
Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。</p>
<h2 id="文件系统">文件系统</h2>
<h3 id="分区与文件系统">分区与文件系统</h3>
<p>对分区进行格式化是为了在分区上建立文件系统，一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。</p>
<h3 id="组成">组成</h3>
<p>最主要的几个组成部分如下：<br>
innode:一个文件占用一个inode,记录文件的属性，同时记录此文件的内容所在block编号。<br>
block：记录文件内容，文件太大时，会占用多个block.<br>
除此之外还包括<br>
superblock:记录文件系统的整体信息，包括inode和block的总量，剩余量，使用量，以及文件系统的格式与相关信息等；<br>
block bitmap：记录block是否被使用的位图。<br>
<img src="https://camo.githubusercontent.com/af36cfca3a3122a49b13b40ec7ec4e54bf15b4c6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f4253445f6469736b2e706e67" alt="" loading="lazy"></p>
<h3 id="文件读取">文件读取</h3>
<p>对于EXT2文件系统，当要读取一个文件的内容时，先在inode中查找文件内容所在的所有block,然后把所有的内容读出来。<br>
<img src="https://camo.githubusercontent.com/d81f8e4f37dc78a5f804a1dbe51c57a26685107f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31326136356363362d323065302d343730362d396665362d3362613439343133643766362e706e67" alt="" loading="lazy"></p>
<p>而对于FAT文件系统，它没有inode,每个block中存储着下一个block的编号。<br>
<img src="https://camo.githubusercontent.com/9e96d72b5464a3db0c8026716079bc44c9cf462a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35623731386538362d373130322d346262362d386361352d6431646437393135333063352e706e67" alt="" loading="lazy"></p>
<h3 id="磁盘碎片">磁盘碎片</h3>
<p>☞一个文件内容所在的block过于分散，导致磁盘磁头移动距离过大，从而降低磁盘的读写性能。</p>
<h3 id="block">block</h3>
<p>在Ext2文件系统中所支持的block大小有1k，2k及4k三种，不同的大小限制了单个文件和文件系统的最大大小。<br>
一个block只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的block。</p>
<h3 id="inode">inode</h3>
<p>inode具体包含以下信息：<br>
权限、拥有者/群组、容量、建立或状态改变时间、最近读取时间、最近修改时间、定义文件特性的旗标、改文件真正内容的指向。</p>
<p>inode具有以下特点：<br>
每个inode大小均固定为128bytes (新的ext4 与 xfs可设定到256bytes)<br>
每个文件都仅会占用一个inode</p>
<p>inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。</p>
<h3 id="目录">目录</h3>
<p>建立一个目录时，会分配一个inode与至少一个block，block记录的内容是目录下所有文件的inode编号以及文件名。<br>
可以看到文件的inode本身不记录文件名，文件名记录在目录中，因此新增文件，删除文件，更改文件名这些操作与目录的写权限有关。</p>
<h3 id="日志">日志</h3>
<p>如果突然断电，那么文件系统会发生错误，例如断电前只修改了block bitmap，而还没有将数据真正写入block中。ext3/ext4文件系统引入了日志功能，可以利用日志来修复文件系统。</p>
<h3 id="挂载">挂载</h3>
<p>挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。</p>
<h3 id="目录配置">目录配置</h3>
<p>为了使不同linux发行版本的目录结构保持一致性，FHS规定了Linux的目录结构。最基础的三个目录如下：<br>
/root /usr /var<br>
<img src="https://camo.githubusercontent.com/b12257cb7875cb1263998e35d1826d5032484d25/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f6c696e75782d66696c6573797374656d2e706e67" alt="" loading="lazy"></p>
<h2 id="文件">文件</h2>
<h3 id="文件属性">文件属性</h3>
<p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。</p>
<p>使用 ls 查看一个文件时，会显示一个文件的信息，例如 drwxr-xr-x 3 root root 17 May 6 00:14 .config，对这个信息的解释如下：</p>
<p>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段<br>
3：链接数<br>
root：文件拥有者<br>
root：所属群组<br>
17：文件大小<br>
May 6 00:14：文件最后被修改的时间<br>
.config：文件名<br>
常见的文件类型及其含义有：</p>
<p>d：目录<br>
-：文件<br>
l：链接文件<br>
9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p>
<p>文件时间有以下三种：</p>
<p>modification time (mtime)：文件的内容更新就会更新；<br>
status time (ctime)：文件的状态（权限、属性）更新就会更新；<br>
access time (atime)：读取文件时就会更新。</p>
<h3 id="文件与目录的基本操作">文件与目录的基本操作</h3>
<p>....</p>
<h3 id="链接">链接</h3>
<figure data-type="image" tabindex="1"><img src="https://camo.githubusercontent.com/160b6c73de6ad65d706650af3e95a7ae6f2be4d6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31653436666430332d306364612d346436302d396231632d3063323536656461663662322e706e67" alt="" loading="lazy"></figure>
<p>实体链接<br>
在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。<br>
删除任意一个条目，文件还是存在，只要引用数量不为 0。<br>
有以下限制：不能跨越文件系统、不能对目录进行链接。</p>
<p>ln /etc/crontab .<br>
ll -i /etc/crontab crontab<br>
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab<br>
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab<br>
符号链接<br>
符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。</p>
<p>当源文件被删除了，链接文件就打不开了。</p>
<p>因为记录的是路径，所以可以为目录建立符号链接。</p>
<p>ll -i /etc/crontab /root/crontab2<br>
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab<br>
53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab</p>
<h2 id="进程管理">进程管理</h2>
<h3 id="查看进程">查看进程：</h3>
<p>ps -l 查看自己的进程<br>
ps aux 查看系统所有进程<br>
ps aux | grep php 查看特定进程<br>
pstree -A 查看所有进程树<br>
top 实时显示进程信息<br>
top -d 2 两秒刷新一次<br>
netstat</p>
<h3 id="查看占用端口的进程">查看占用端口的进程</h3>
<p>netstat -anp | grep port</p>
<h3 id="进程状态">进程状态</h3>
<figure data-type="image" tabindex="2"><img src="https://camo.githubusercontent.com/18fd4fa4f90c39ea3024bc7e330940ed5761b201/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32626162343132372d336537642d343863632d393134652d3433366265383539666230352e706e67" alt="" loading="lazy"></figure>
<h3 id="sigchld">SIGCHLD</h3>
<p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p>
<p>得到 SIGCHLD 信号；<br>
waitpid() 或者 wait() 调用会返回。<br>
其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。</p>
<p>在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。</p>
<h3 id="wait">wait()</h3>
<p>父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。</p>
<p>如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。</p>
<p>参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。</p>
<h3 id="waitpid">waitpid()</h3>
<p>作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。</p>
<p>pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。</p>
<p>options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。</p>
<h3 id="孤儿进程">孤儿进程</h3>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p>
<p>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p>
<p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p>
<h3 id="僵尸进程">僵尸进程</h3>
<p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>
<p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p>
<p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>
<h2 id="系统诊断命令">系统诊断命令</h2>
<h3 id="free">free</h3>
<p>需要学会查看系统内存 未使用的内容 = free + buffers + cached -m 单位转换M -g 单位转换为G</p>
<h3 id="vmstat">vmstat</h3>
<p>分析系统问题<br>
r (running) 列表运行和等待的进程数量，如果长期大于1说明cpu不足，需要cpu。<br>
b 列表等待资源的进程数，如等待I/O，或者内存交换等。</p>
<p>cpu使用状态<br>
us 表示用户进程cpu时间占比，如果长期大于50%,需要考虑优化用户程序。<br>
sy 显示了内核进程cpu时间占比，如果us + sy 大于80%说明可能存在CPU不足。<br>
wa 显示了IO等待所占用的CPU时间的百分比，说明IO等待严重，磁盘大量随机访问造成的，也可能是磁盘或者磁盘访问控制器带宽瓶颈造成的<br>
id cpu处于空闲的百分比</p>
<p>system显示采集间隔中观察到的每秒设备中断数。<br>
in 列表在某一时间间隔中观察到的每秒设备中断数<br>
cs 表示每秒产生的上下文切换次数</p>
<p>memory 内存情况<br>
swpd 切换到内存交换区的内存数量，如果swpd的值不为0，或者比较大，只要si,so的长期为0，系统性能还是正常<br>
free 当前的空闲页面列表中内存数量(k表示)<br>
buff 作为buffer cache的内存数量，一般对块设备的读写才需要缓冲。<br>
cache 作为page cache的内存数量，一般作为文件系统的cache，如果cache较大，说明用到cache的文件较多，如果此时IO中bi比较小，说明文件系统效率比较好。</p>
<p>swap<br>
si 由内存进入内存交换区数量<br>
so 有内存交换区进入内存数量</p>
<p>IO<br>
bi 从块设备读入数据的总量（读磁盘）（每秒kb）<br>
bo 块设备写入数据的总量(写磁盘)（每秒kb）<br>
这里我们设置的bi+bo参考值为1000，如果超过1000，而且wa值较大应该考虑均衡磁盘负载，可以结合iostat输出来分析。</p>
<h3 id="dd">dd</h3>
<p>模拟读写磁盘操作</p>
<h3 id="top">top</h3>
<p>系统</p>
<h3 id="watch-more-procnetdev">watch more /proc/net/dev</h3>
<p>用于定位丢包，错报情况，以便看望了瓶颈</p>
<h3 id="netstat">netstat</h3>
<p>查看端口</p>
<h3 id="ping">ping</h3>
<h3 id="traceroute-ip">traceroute ip</h3>
<p>路由追踪</p>
<h3 id="dig">dig</h3>
<p>查看域名解析</p>
<h3 id="dmesg">dmesg</h3>
<p>查看系统日志</p>
<h3 id="df">df</h3>
<p>查看磁盘剩余空间</p>
<h3 id="du">du</h3>
<p>查看磁盘使用空间</p>
<h3 id="ps">ps</h3>
<p>查看进程</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机操作系统-链接]]></title>
        <id>https://miexxx.github.io/post/ji-suan-ji-cao-zuo-xi-tong-lian-jie/</id>
        <link href="https://miexxx.github.io/post/ji-suan-ji-cao-zuo-xi-tong-lian-jie/">
        </link>
        <updated>2020-03-31T13:44:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="编译系统">编译系统</h1>
<p>以下是一个hello.c程序</p>
<pre><code>#include &lt;stdio.h&gt;

int main()
{
    printf(&quot;hello, world\n&quot;);
    return 0;
}

</code></pre>
<p>在Unix系统上，由于编译器把源文件转换为目标文件。</p>
<pre><code>gcc -o hello hello.c
</code></pre>
<p>这个过程大致如下：<br>
<img src="https://camo.githubusercontent.com/e1da518d4b62181167c2b1fea745c9bcc6b44c35/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62333936643732362d623735662d346133322d383961322d3033613762366531396636662e6a7067" alt="" loading="lazy"></p>
<p>预处理阶段：处理以 # 开头的预处理命令；<br>
编译阶段：翻译成汇编文件；<br>
汇编阶段：将汇编文件翻译成可重定位目标文件；<br>
链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</p>
<h1 id="静态链接">静态链接</h1>
<p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p>
<p>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。<br>
重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。<br>
<img src="https://camo.githubusercontent.com/33c7b278162d2fde0df39a36dc9943ff03f9aa05/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34376439383538332d386262302d343563632d383132642d3437656566613061346134302e6a7067" alt="" loading="lazy"></p>
<h1 id="动态链接">动态链接</h1>
<p>静态库有以下两个问题：</p>
<p>当静态库更新时那么整个程序都要重新进行链接；<br>
对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。<br>
共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<p>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；<br>
在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。<br>
<img src="https://camo.githubusercontent.com/f684ca99d53f8992733f530d09165309e6f72e87/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37366463373736392d316161632d343838382d396265612d3036346631636161386537372e6a7067" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机操作系统-设备管理]]></title>
        <id>https://miexxx.github.io/post/ji-suan-ji-cao-zuo-xi-tong-she-bei-guan-li/</id>
        <link href="https://miexxx.github.io/post/ji-suan-ji-cao-zuo-xi-tong-she-bei-guan-li/">
        </link>
        <updated>2020-03-31T13:38:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="磁盘结构">磁盘结构</h1>
<p>盘面（Platter）：一个磁盘有多个盘面；<br>
磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；<br>
扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；<br>
磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；<br>
制动手臂（Actuator arm）：用于在磁道之间移动磁头；<br>
主轴（Spindle）：使整个盘面转动。</p>
<figure data-type="image" tabindex="1"><img src="https://camo.githubusercontent.com/42c8be3472d81b72762c2a88b29fa61b4bdf2409/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30313466626334642d643837332d346131322d623136302d3836376464616564393830372e6a7067" alt="" loading="lazy"></figure>
<h1 id="磁盘调度算法">磁盘调度算法</h1>
<p>读写一个磁盘块的时间的影响因素有：</p>
<p>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）<br>
寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）<br>
实际的数据传输时间<br>
其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>
<h2 id="先来先服务">先来先服务</h2>
<p>按照磁盘请求的顺序进行调度。<br>
优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<h2 id="最短寻道时间优先">最短寻道时间优先</h2>
<p>优先调度与当前磁头所在磁道距离最近的磁道。</p>
<p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。<br>
<img src="https://camo.githubusercontent.com/513755459b87116ae3a03bb9c4c6a0b161e7d0ed/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34653234383565342d333462642d343936372d396630322d3063303933623739376161612e706e67" alt="" loading="lazy"></p>
<h2 id="电梯算法">电梯算法</h2>
<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。<br>
电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。<br>
因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。<br>
<img src="https://camo.githubusercontent.com/8187903788bbfb90978169f20fa4fd41e094bf22/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373163653038662d633132342d343735662d623439302d6265343466656463366432652e706e67" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机操作系统-内存管理]]></title>
        <id>https://miexxx.github.io/post/ji-suan-ji-cao-zuo-xi-tong-nei-cun-guan-li/</id>
        <link href="https://miexxx.github.io/post/ji-suan-ji-cao-zuo-xi-tong-nei-cun-guan-li/">
        </link>
        <updated>2020-03-25T12:02:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="虚拟内存">虚拟内存</h1>
<p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。<br>
为了更好的管理内存，操作系统将内存抽象成地址空间，每一个程序拥有自己的地址空间，这个地址空间被分割成多个块。每一块称为一页，这些页被映射到物理内存，但不需要所有页都必须在物理内存中。当程序引用到不再物理内存的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面描述中可以看出，虚拟内存运行程序不用将地址空间的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序称为可能。例如有一台计算机可以产生16位地址，那么一个程序的地址空间范围是0~64k，该计算机只有32KB的物理内存，虚拟内存技术允许该计算机运行一个64k大小的程序。<br>
<img src="https://camo.githubusercontent.com/a11aa3279eb780cafdcb9abdeb41047960ea7518/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37623238316231652d303539352d343032622d616533352d3863393130383463333363312e706e67" alt="" loading="lazy"></p>
<h1 id="分页系统地址映射">分页系统地址映射</h1>
<p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。<br>
一个虚拟地址分为两部分，一部分存储页面号，一部分存储偏移量。</p>
<h1 id="页面置换算法">页面置换算法</h1>
<p>在程序运行过程中，如果要访问的页面不存在内存中，就发生缺页中断从而将该页调入内存中，此时如果内存已无空闲空间，系统必须从内存调出一个页面到磁盘对换区中腾出空间。<br>
页面置换算法和淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p>
<p>页面置换算法的主要目的是使置换频率最低，也可以说缺页率最低。</p>
<h2 id="最佳">最佳</h2>
<p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。<br>
是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。<br>
举例：</p>
<pre><code>7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1
</code></pre>
<p>开始运行时，先将7，0，1三个页面装入内存。当程序要访问页面2时，产生缺页中断，会将页面7换出，应为页面7再次被访问的时间最长。</p>
<h2 id="最近最久未使用">最近最久未使用</h2>
<p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。<br>
为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。<br>
因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p>
<pre><code>4，7，0，7，1，0，1，2，1，2，6
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://camo.githubusercontent.com/88a3ea6558a8b9326f6fd95d74b2ff07625427b5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65623835393232382d633066322d346263652d393130642d6439663736393239333532622e706e67" alt="" loading="lazy"></figure>
<h2 id="最近未使用">最近未使用</h2>
<p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：<br>
R=0，M=0<br>
R=0，M=1<br>
R=1，M=0<br>
R=1，M=1<br>
当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。<br>
NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p>
<h2 id="先进先出">先进先出</h2>
<p>选择换出的页面是最先进入的页面。<br>
该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</p>
<h2 id="第二次机会算法">第二次机会算法</h2>
<p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p>
<p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。<br>
<img src="https://camo.githubusercontent.com/033a579c02954e1414f31564e9c14f872e3c6daf/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65636638616435642d353430332d343862392d623665372d6632653230666665386663612e706e67" alt="" loading="lazy"></p>
<h2 id="时钟">时钟</h2>
<p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。<br>
<img src="https://camo.githubusercontent.com/be6880af7be4c35175b739114a78d6bf151c740f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35663565663062362d393865612d343937632d613030372d6636633535323838656162312e706e67" alt="" loading="lazy"></p>
<h1 id="分段">分段</h1>
<p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。<br>
下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。<br>
<img src="https://camo.githubusercontent.com/4ec196194b9ad1ae598a14f1b07399364cff4ee2/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32326465303533382d376336652d343336352d626433622d3863653363353930303231362e706e67" alt="" loading="lazy"><br>
分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。<br>
<img src="https://camo.githubusercontent.com/c336d65110524ae289477dc2a0636edf6aef9a3c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65303930306262322d323230612d343362372d396161392d3164356364353566663536652e706e67" alt="" loading="lazy"></p>
<h1 id="段页式">段页式</h1>
<p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p>
<h1 id="分页与分段的比较">分页与分段的比较</h1>
<p>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。<br>
地址空间的维度：分页是一维地址空间，分段是二维的。<br>
大小是否可以改变：页的大小不可变，段的大小可以动态改变。<br>
出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机操作系统-死锁]]></title>
        <id>https://miexxx.github.io/post/ji-suan-ji-cao-zuo-xi-tong-si-suo/</id>
        <link href="https://miexxx.github.io/post/ji-suan-ji-cao-zuo-xi-tong-si-suo/">
        </link>
        <updated>2020-03-19T13:07:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="产生死锁的必要条件">产生死锁的必要条件</h1>
<p><img src="https://camo.githubusercontent.com/1a8800931db59afc3925e96446601d198d8df9da/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63303337633930312d376561652d346533312d613165342d3964343133323965356333652e706e67" alt="" loading="lazy"><br>
互斥：每个资源要么已经分配给了一个进程，要么就是可用的。<br>
占有和等待：已经得到了某个资源的进程可以再请求新的资源。<br>
不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。<br>
环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</p>
<h1 id="处理方法">处理方法</h1>
<p>主要有以下四种方法：<br>
鸵鸟策略<br>
死锁检测与死锁恢复<br>
死锁预防<br>
死锁避免</p>
<h2 id="鸵鸟策略">鸵鸟策略</h2>
<p>把头埋在沙子里，假装根本没发生问题。<br>
因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。<br>
当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。<br>
大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h2 id="死锁检测与死锁恢复">死锁检测与死锁恢复</h2>
<p>不试图阻止死锁，而是当检测到死锁发送时，采取措施进行恢复。</p>
<h3 id="每种类型一个资源的死锁检测">每种类型一个资源的死锁检测</h3>
<p><img src="https://camo.githubusercontent.com/ccebd10711103f30cd895559e28fe8daa9738e78/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62316661303435332d613462302d346561652d613335322d3438616363613866666637342e706e67" alt="" loading="lazy"><br>
上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。<br>
图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。<br>
每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p>
<h3 id="死锁恢复">死锁恢复</h3>
<p>利用抢占恢复<br>
利用回滚恢复<br>
通过杀死进程恢复</p>
<h1 id="死锁预防">死锁预防</h1>
<p>在程序运行之前预防发生死锁。</p>
<h2 id="破坏互斥条件">破坏互斥条件</h2>
<p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>
<h2 id="破坏占有和等待条件">破坏占有和等待条件</h2>
<p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>
<h2 id="破坏不可抢占条件">破坏不可抢占条件</h2>
<h2 id="破坏环路等待">破坏环路等待</h2>
<p>给资源统一编号，进程只能按编号顺序来请求资源。</p>
<h1 id="死锁避免">死锁避免</h1>
<p>在程序运行时避免发送死锁。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RabbitMQ]]></title>
        <id>https://miexxx.github.io/post/rabbitmq-ji-zhu-diao-yan/</id>
        <link href="https://miexxx.github.io/post/rabbitmq-ji-zhu-diao-yan/">
        </link>
        <updated>2020-03-16T07:09:54.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="beanstalkd">Beanstalkd</h2>
<p>Beantalkd 一个轻量级消息中间件，他的最大特点是将自己定位为基于管道  (tube) 和任务 (job) 的工作队列 (work-queue)<br>
有以下特点：</p>
<h3 id="任务优先级-priority">任务优先级 (priority):</h3>
<p>任务 (job) 可以有 0~2^32 个优先级, 0 代表最高优先级。 beanstalkd 采用最大最小堆 (Min-max heap) 处理任务优先级排序, 任何时刻调用 reserve 命令的消费者总是能拿到当前优先级最高的任务, 时间复杂度为 O(logn)。</p>
<h4 id="最大堆与最小堆">最大堆与最小堆</h4>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdn.net/20160317150649506" alt="" loading="lazy"></figure>
<p><img src="https://img-blog.csdn.net/20160317150655703" alt="" loading="lazy"><br>
堆树是一种二叉树，堆树中某个节点的值总是不大于或不小于其孩子节点的值。<br>
当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。 当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆。</p>
<h3 id="延时任务-delay">延时任务 (delay):</h3>
<p>有两种方式可以延时执行任务 (job): 生产者发布任务时指定延时，或者当任务处理完毕后, 消费者再次将任务放入队列延时执行 (RELEASE with )。</p>
<h3 id="任务超时重发-time-to-run">任务超时重发 (time-to-run):</h3>
<p>Beanstalkd 把任务返回给消费者以后：消费者必须在预设的 TTR (time-to-run) 时间内发送 delete / release/ bury 改变任务状态；否则 Beanstalkd 会认为消息处理失败，然后把任务交给另外的消费者节点执行。如果消费者预计在 TTR (time-to-run) 时间内无法完成任务, 也可以发送 touch 命令, 它的作用是让 Beanstalkd 从系统时间重新计算 TTR (time-to-run)。</p>
<h3 id="任务预留-buried">任务预留 (buried):</h3>
<p>如果任务因为某些原因无法执行, 消费者可以把任务置为 buried 状态让 Beanstalkd 保留这些任务。管理员可以通过 peek buried 命令查询被保留的任务，并且进行人工干预。简单的, kick 能够一次性把 n 条被保留的任务踢回队列。</p>
<h3 id="消息持久化">消息持久化</h3>
<p>通过日志实现消息的持久化。</p>
<h3 id="速度优势">速度优势</h3>
<p><img src="https://pic1.zhimg.com/80/dbbd8ac979caf1400eda6974edd4d712_1440w.jpg" alt="" loading="lazy"><br>
Beanstalkd协议基于tcp上。客户端连接服务器并发送指令和数据，然后等待响应并关闭连接。对于每个连接，服务器按照接收命令的序列依次处理并响应。</p>
<h3 id="场景优势">场景优势</h3>
<p>延时系统，比如延迟20分钟发送短信，******，在投放的时候就设定一定的延迟时间值，让任务在延迟时间到了之后进入ready队列，等待worker预订处理。<br>
<img src="https://pic4.zhimg.com/80/b2fe6330ac4cee0ace41e47a82bf713f_1440w.jpg" alt="" loading="lazy"></p>
<p>轮询系统，如下图，一个被投放的任务，在延迟时间过后需要再检查一遍状态，如果不符合，继续释放（release with delay）为延迟投放状态（DELAYED），直到时间过期之后，再次进入ready队列，被worker预订，进行一些逻辑判断，比如微信银行卡退款是否成功，如果成功，删除该任务，如果没成功，继续释放（release with delay）为延迟投放状态。<br>
<img src="https://pic1.zhimg.com/80/8add0f140c21e738f26b1ccd8d2fa892_1440w.jpg" alt="" loading="lazy"></p>
<h3 id="缺陷">缺陷</h3>
<p>Beanstalk单点部署，不支持集群，当服务发送故障造成服务不可用，任务积压问题，不能够灵活的设置消息持久化。</p>
<hr>
<h2 id="rabbitmq">RabbitMQ</h2>
<h3 id="rabbitmq特性">Rabbitmq特性</h3>
<p>可靠性：持久化存储、ACK消息确认、发布confirm、事务支持。<br>
灵活的路由：交换机功能。交换机类型：direct,topic,headers,fanout。<br>
镜像，master-slave 多协议支持,集群节点<br>
多语言客户端支持：java、c#、ruby、Python、php、c、scale、nodejs、go、erlang…<br>
管理界面功能丰富、命令行rabbitmqctl、RPC远程调度</p>
<h3 id="amqp高级消息协议">AMQP高级消息协议</h3>
<p>一个AMQP服务器类似于邮件服务器，exchange类似于消息传输代理（email里的概念），message queue类似于邮箱。Binding定义了每一个传输代理中的消息路由表，发布者将消息发给特定的传输代理，然后传输代理将这些消息路由到邮箱中，消费者从这些邮箱中取出消息。</p>
<p>AMQP术语<br>
Channel（信道）： 在AMQP模型中，我们不需要通过建立太多的TCP连接来实现。假如针对每一个AMQP连接都建立一个TCP连接的话，会占用大量的系统资源。对此，AMQP提供了通道（channel）机制。即，共享一个TCP连接，可创建多个通道。<br>
​ 在多线程/进程的应用程序中正确做法是，对于每一个线程/进程，应分别建立一个通道，而不是多个线程/进程之间去共享一个通道。<br>
Exchange（交换器）：用于接受、分配消息；可以有好几种模式、相当于邮箱<br>
Queue（队列）：用于存储生产者的消息；<br>
RoutingKey（路由键）：用于把生成者的数据分配到交换器上；<br>
BindingKey（绑定键）：用于把交换器的消息绑定到队列上；<br>
Broker（消息代理）：消息代理会接收来自生产者（publishers/producers）生产的消息，并将它们路由(route，可以理解成按指定规则转发)给相应的消费者(consumers)手中。<br>
VHOST（虚拟主机）：为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP 提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟 Web servers 虚拟主机概念非常相似，这为 AMQP 实体提供了完全隔离的环境。当连接被建立的时候，AMQP 客户端来指定使用哪个虚拟主机。</p>
<p><a href="http://tryrabbitmq.com/">模拟器</a></p>
<h3 id="hello-world">hello world</h3>
<p>生产者生产消息，消费者消费消息，消息存储在队列中。<br>
<img src="https://www.rabbitmq.com/img/tutorials/python-one.png" alt="" loading="lazy"><br>
生产者：</p>
<pre><code>函数：
// 声明队列
public function queue_declare(
        $queue = '',            //队列名称
        $passive = false,      //如果只是需要知道该队列是否存在，传递true
        $durable = false,       //队列可持久话，如果希望节点关闭也不会丢失队列，传递true
        $exclusive = false,      //排他性，针对首次建立连接的，一个连接下面多个通道也是可见的， 对于其他连接是不可见的，断开连接后自动删除
        $auto_delete = true,   //自动删除，默认是开启的，最后一个消息被消费后自动删除队列
        $nowait = false,
        $arguments = array(), //可用于镜像队列配置
        $ticket = null
    ) {}

// 发布消息
     public function basic_publish(
        $msg,                       // 消息体
        $exchange = '',           // 交换器，默认direct。
        $routing_key = '',         // 路由key  
        $mandatory = false,      //当mandatory标志位设置为true时，如果exchange根据自身类型和消息routeKey无法找到一个符合条件的queue，那么会调用basic.return方法将消息返回给生产者（Basic.Return + Content-Header + Content-Body）
        $immediate = false,         //当immediate标志位设置为true时，如果exchange在将消息路由到queue(s)时发现对于的queue上么有消费者，那么这条消息不会放入队列中。当与消息routeKey关联的所有queue（一个或者多个）都没有消费者时，该消息会通过basic.return方法返还给生产者。
        $ticket = null                     // 暂时没发现用途
    ) {}
</code></pre>
<p>消费者：</p>
<pre><code>public function basic_consume(
        $queue = '',                        // 队列名称
        $consumer_tag = '',             // 消费者标签
        $no_local = false,                 // 
        $no_ack = false,                   // 消息ack
        $exclusive = false,
        $nowait = false,
        $callback = null,                   // 回调函数
        $ticket = null,
        $arguments = array()
    ) {}
</code></pre>
<h3 id="工作队列">工作队列</h3>
<p>一个工作队列，该队列将用于在多个工作人员之间分配耗时的任务,默认情况下，RabbitMQ将按顺序将每个消费者都会收到相同数量的消息，采用循环发送的方式。</p>
<h4 id="消息确认">消息确认</h4>
<p>执行任务可能需要几秒钟。您可能想知道，如果其中一个消费者开始一项漫长的任务并仅部分完成而死掉，会发生什么情况。使用我们当前的代码，RabbitMQ一旦向消费者发送了一条消息，便立即将其标记为删除。在这种情况下，如果您杀死一个工人，我们将丢失正在处理的消息。我们还将丢失所有发送给该特定工作人员但尚未处理的消息。但是我们不想丢失任何任务。如果一个工人死亡，我们希望将任务交付给另一个工人。<br>
为了确保消息永不丢失，RabbitMQ支持 消息确认。消费者发送回一个确认（acknowledgement），以告知RabbitMQ已经接收，处理了特定的消息，并且RabbitMQ可以自由删除它。<br>
如果使用者死了（其通道已关闭，连接已关闭或TCP连接丢失）而没有发送确认，RabbitMQ将了解消息未完全处理，并将重新排队。如果同时有其他消费者在线，它将很快将其重新分发给另一位消费者。这样，即使工人偶尔死亡，您也可以确保不会丢失任何消息。没有任何消息超时；消费者死亡时，RabbitMQ将重新传递消息。</p>
<p>如果当我们的消费者大量的消息内容忘记ack后，会照成rabbitMq将会消耗越来越多的内存，因为它无法释放任何未确认的消息。<br>
rabbitmqctl list_queues name messages_ready messages_unacknowledged<br>
以上命令可以查询队列中的为确认消息数量。</p>
<h4 id="消息持久性">消息持久性</h4>
<p>以上方法，已经能够解决消费者死亡，任务也不会丢失，但是，如果RabbitMQ服务器停止，我们的任务仍然会丢失，要确保消息不会丢失，需要做两件事，将队列与消息都是标记为持久性。</p>
<pre><code>// 队列持久化
$ channel-&gt; queue_declare（'task_queue'，false，true，false，false）;

// 消息持久化
$ msg = new AMQPMessage（
    $ data，array（'delivery_mode' =&gt; AMQPMessage :: DELIVERY_MODE_PERSISTENT）
）;
</code></pre>
<p>将消息标记持久化并不能完全保证不会丢失消息，应为RabbitMQ接收消息但尚未保存至磁盘中时还是有很短的时间，另外，RabbitMQ不会对每条消息都执行fsync(2)，可能只是保存到缓存中，而没有真正写入磁盘，持久性保证并不强，但是对于简单的任务队列而已，已经足够了，如果需要更强有力的保证，则可以使用<a href="https://www.rabbitmq.com/confirms.html#basics">发布者确认</a>。</p>
<pre><code>$channel-&gt;confirm_select(); //开启确认模式
$channel-&gt;basic_publish($msg, $exchangeName, $routeingKey);
 
//注册ack回调
$channel-&gt;set_nack_handler(function (AMQPMessage $msg) {
    var_dump('nack');
});
$channel-&gt;set_ack_handler(function (AMQPMessage $msg) {
    var_dump(&quot;ack&quot;);
});
//等待接收ack
$channel-&gt;wait_for_pending_acks();
</code></pre>
<h4 id="公平派遣">公平派遣</h4>
<p>您可能已经注意到，调度仍然无法完全按照我们的要求进行。例如，在有两名工人的情况下，当所有奇怪的消息都很重，甚至消息都很轻时，一位工人将一直忙碌而另一位工人将几乎不做任何工作。好吧，RabbitMQ对此一无所知，并且仍将平均分配消息。发生这种情况是因为RabbitMQ在消息进入队列时<br>
<img src="https://www.rabbitmq.com/img/tutorials/prefetch-count.png" alt="" loading="lazy"><br>
为了克服这一点，我们可以将basic_qos方法与 prefetch_count = 1设置一起使用。这告诉RabbitMQ一次不要给工人一个以上的消息。换句话说，在处理并确认上一条消息之前，不要将新消息发送给工作人员。而是将其分派给尚不繁忙的下一个工作人员。</p>
<pre><code>$ channel-&gt; basic_qos（null，1，null）;
</code></pre>
<h3 id="发布订阅">发布订阅</h3>
<p>一次发布，订阅的队列都能接收到消息进行处理，将繁琐的业务逻辑进行解耦。<br>
<img src="https://www.rabbitmq.com/img/tutorials/exchanges.png" alt="" loading="lazy"><br>
每个订阅者就是一个队列，虽然这场景也可以通过一个队列进行所有业务操作，但是一旦一个复杂的业务发生故障，容易服务不可用任务积压，如果能够将业务拆分的更加小，每个队列处理自己的业务逻辑，能够很好解决这一问题，采用发布订阅模式，发布者不需要关系哪些队列关注这个任务，只要订阅了，自动回接收到任务。<br>
有几种交换类型：direct,topic,headers,fanout。<br>
生产者：</p>
<pre><code> $channel = $connection-&gt;channel();
    $channel-&gt;exchange_declare($exchangeName, 'fanout', false, false, false);
    $n = 1;
    while ($n &lt; 10) {
        $msg = new \PhpAmqpLib\Message\AMQPMessage(
            &quot;fanout message !!! $n&quot;
        );
        $channel-&gt;basic_publish($msg, $exchangeName);
        $n ++;
    }
    $channel-&gt;close();
    $connection-&gt;close();
</code></pre>
<p>消费者：</p>
<pre><code>$channel = $connection-&gt;channel();
    $channel-&gt;queue_declare($queueName, false, false, false, false);
    $channel-&gt;queue_bind($queueName, $exchangeName);
    $callback = function ($msg) {
        echo ' [x] ', $msg-&gt;body, &quot;\n&quot;;
    };
    $channel-&gt;basic_consume($queueName, '', false, true, false, false, $callback);
    while ($channel-&gt;is_consuming()) {
        $channel-&gt;wait();
    }
    $channel-&gt;close();
    $connection-&gt;close();
</code></pre>
<h3 id="路由">路由</h3>
<p><img src="https://www.rabbitmq.com/img/tutorials/direct-exchange.png" alt="" loading="lazy"><br>
在发布订阅的基础上，有些队列并不需要接收所有消息，而是只对自己感兴趣的内容进行订阅，这就是路由的功能，生成消息时可以添加routing-key进行绑定，发送到指定队列。<br>
生产者:</p>
<pre><code> $channel = $connection-&gt;channel();
    $channel-&gt;exchange_declare($exchangeName, 'direct', false, false, false);
    $n = 1;
    while ($n &lt; 10) {
        $msg = new \PhpAmqpLib\Message\AMQPMessage(
            &quot;direct routing message !!! $n&quot;
        );
        $channel-&gt;basic_publish($msg, $exchangeName, $routingKey);
        $n ++;
    }
    $channel-&gt;close();
    $connection-&gt;close();
</code></pre>
<p>消费者：</p>
<pre><code>$channel = $connection-&gt;channel();
    $channel-&gt;queue_declare($queueName, false, false, false, false);
    $channel-&gt;queue_bind($queueName, $exchangeName, $routingKey);
    $callback = function ($msg) {
        echo ' [x] ', $msg-&gt;delivery_info['routing_key'], $msg-&gt;body, &quot;\n&quot;;
    };
    $channel-&gt;basic_consume($queueName, '', false, true, false, false, $callback);
    while ($channel-&gt;is_consuming()) {
        $channel-&gt;wait();
    }
    $channel-&gt;close();
    $connection-&gt;close();
</code></pre>
<h3 id="主题">主题</h3>
<p>路由功能虽然解决了，订阅者只接收自己订阅的内容，但是如果用户可能想要接收到，某一类相关的消息，就需要同topic功能， 主题交流不具有任意routing-key，routing-key必须是单词列表以&quot;.&quot;分隔，单词可以使用&quot;*&quot;通配符表示，&quot;#&quot;绑定表示接收所有消息,和直接订阅效果一样。<br>
生产者：</p>
<pre><code> $channel = $connection-&gt;channel();
    $channel-&gt;exchange_declare($exchangeName, 'topic', false, false, false);
    $n = 1;
    while ($n &lt; 10) {
        $msg = new \PhpAmqpLib\Message\AMQPMessage(
            &quot;topic routing message !!! $n&quot;
        );
        $channel-&gt;basic_publish($msg, $exchangeName, $routingKey);
        $n ++;
    }
    $channel-&gt;close();
    $connection-&gt;close();
</code></pre>
<p>消费者:</p>
<pre><code> $channel = $connection-&gt;channel();
    $channel-&gt;queue_declare($queueName, false, false, false, false);
    $channel-&gt;queue_bind($queueName, $exchangeName, $routingKey);
    $callback = function ($msg) {
        echo ' [x] ', $msg-&gt;delivery_info['routing_key'], $msg-&gt;body, &quot;\n&quot;;
    };
    $channel-&gt;basic_consume($queueName, '', false, true, false, false, $callback);
    while ($channel-&gt;is_consuming()) {
        $channel-&gt;wait();
    }
    $channel-&gt;close();
    $connection-&gt;close();
</code></pre>
<h3 id="rpc">RPC</h3>
<p>有关RPC的说明<br>
尽管RPC是计算中非常普遍的模式，但它经常受到批评。当程序员不知道函数调用是本地的还是缓慢的RPC时，就会出现问题。这样的混乱会导致系统变幻莫测，并给调试增加了不必要的复杂性。滥用RPC可能会导致无法维护的意大利面条代码，而不是简化软件。<br>
牢记这一点，请考虑以下建议：<br>
确保明显的是哪个函数调用是本地的，哪个是远程的。<br>
记录您的系统。明确组件之间的依赖关系。<br>
处理错误案例。RPC服务器长时间关闭后，客户端应如何反应？<br>
如有疑问，请避免使用RPC。如果可以的话，应该使用异步管道-代替类似RPC的阻塞，将结果异步推送到下一个计算阶段。<br>
<img src="https://www.rabbitmq.com/img/tutorials/python-six.png" alt="" loading="lazy"><br>
客户端启动时，它将创建一个匿名排他回调队列。<br>
对于RPC请求，客户端发送一条消息，该消息具有两个属性： reply_to（设置为回调队列）和correlation_id（设置为每个请求的唯一值）。<br>
该请求被发送到rpc_queue队列。<br>
RPC工作程序（又名：服务器）正在等待该队列上的请求。出现请求时，它将使用reply_to字段中的队列来完成工作，并将消息和结果发送回客户端。<br>
客户端等待回调队列上的数据。出现消息时，它将检查correlation_id属性。如果它与请求中的值匹配，则将响应返回给应用程序。<br>
客户端将请求发送到rpc_queue队列，需要传递请求唯一id，请求的回调队列。<br>
rpc_service服务端，消费rpc_queue队列，接收到消息后进行逻辑处理，再将数据放入回调队列中。<br>
rpc_client客户端，需要生产消息到rpc_queue,同时消费回调队列的结果correlation_id相同时返回结果。</p>
<h3 id="集群">集群</h3>
<p>RabbitMQ始终记录的四种类型的内部元数据：<br>
队列元数据 - 队列名称和他们的属性<br>
交换器元数据 - 交换器名称、类型和属性<br>
绑定元数据  - 一张简单的表格展示了如何将消息路由到队列<br>
vhost元数据 - 为vhost内的队列、交换器、绑定提供命名空间和安全属性。</p>
<h4 id="单机多节点部署">单机多节点部署</h4>
<p>RABBITMQ_NODE_PORT:指定rmq端口<br>
RABBITMQ_NODENAME:指定节点名称与域名<br>
rabbitmq-server -detached 后台运行<br>
RABBITMQ_SERVER_START_ARGS：启动服务参数<br>
-rabbitmq_management listener [{port,15673}] 管理后台监听端口<br>
-rabbitmq_stomp tcp_listeners [61614] rabbitmq_stomp tcp服务使用端口<br>
-rabbitmq_mqtt  tcp_listeners [1884]rabbitmq_mqtt tcp服务使用端口</p>
<p>第一个节点：<br>
命令：RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit@localhost rabbitmq-server -detached<br>
http://localhost:15674/#/ 地址能够进入对应节点管理后台。</p>
<p>第二个节点：<br>
注意：在单机部署多节点的时候，命令会有所不同，需要添加一些参数修改对应服务使用的端口，否则会出现端口冲突，节点无法启动。<br>
RABBITMQ_NODE_PORT=5673 RABBITMQ_SERVER_START_ARGS=&quot;-rabbitmq_management listener [{port,15673}] -rabbitmq_stomp tcp_listeners [61614] -rabbitmq_mqtt  tcp_listeners [1884]&quot; RABBITMQ_NODENAME=rabbit2@localhost rabbitmq-server  -detached</p>
<p>第三个节点：<br>
RABBITMQ_NODE_PORT=5674 RABBITMQ_SERVER_START_ARGS=&quot;-rabbitmq_management listener [{port,15674}] -rabbitmq_stomp tcp_listeners [61615] -rabbitmq_mqtt  tcp_listeners [1885]&quot; RABBITMQ_NODENAME=rabbit2@localhost rabbitmq-server  -detached</p>
<p>添加节点步骤：<br>
rabbitmqctl -n rabbit1@localhost stop_app               //暂停节点服务<br>
rabbitmqctl -n rabbit1@localhost reset                     //节点重置，将节点所属的cluster都删除。<br>
rabbitmqctl -n rabbit1@localhost join_cluster rabbit@localhost  //将rabbit1节点加入集群 默认是disk 磁盘节点模式 --ram 可以指定为内存节点模式<br>
rabbitmqctl -n rabbit1@localhost start_app                              //启动节点<br>
rabbitmqctl cluster_status -n rabbit@localhost                          //查看集群情况<br>
rabbit1只需要加入这个集群中任意一台节点就可以加入集群。</p>
<p>删除节点步骤：<br>
方法一：<br>
rabbitmqctl -n rabbit1@localhost stop_app               //暂停节点服务<br>
rabbitmqctl -n rabbit1@localhost reset                     //节点重置，将节点所属的cluster都删除。</p>
<p>方法二：<br>
rabbitmqctl -n rabbit1@localhost stop_app               //暂停节点服务<br>
rabbitmqctl forget_cluster_node rabbit1@localhost      //集群中移除节点</p>
<h4 id="内存节点与磁盘节点的区别">内存节点与磁盘节点的区别</h4>
<p>网上说的云里雾里的，这边总结一下，只要队列和消息指定持久化，都会落地到磁盘中，内存节点和磁盘节点的区别就是将元数据放在了内存还是硬盘，仅此而已，当在集群中声明队列、交换器和绑定 ，这些操作会同步元数据到所有节点，所以一个集群至少要有一个磁盘节点来同步元数据。<br>
元数据必须至少保存在一个硬盘上，内存节点重启会去磁盘节点下载当前集群元数据拷贝，磁盘节点全挂了，那么集群就无法创建新的东西了，但是还能继续使用已有的东西。</p>
<p>默认情况下，队列只会保存在一个节点上，其他只是保存元数据，当然消息也会投递到这个队列所在的机器上<br>
所以我们才有了创建镜像队列的需求，镜像队列则需要队列适配了策略，当一个节点挂掉后，其他节点都会有这个节点的镜像队列，选择其中一个节点作为新的队列master。</p>
<p>rabbitmqctl set_policy ha-all &quot;^&quot; '{&quot;ha-mode&quot;:&quot;all&quot;, &quot;ha-sync-mode&quot;:&quot;automatic&quot;}'<br>
将所有队列都是设置为镜像队列并且自动同步，是否需要自动同步可以根据自己需求进行设置， 也可以设置需要镜像同步的节点数，个人感觉一个master节点一个mirror节点就足够了。</p>
<h4 id="负载均衡">负载均衡</h4>
<p>HAProxy 提供高可用性、负载均衡以及基于 TCP 和 HTTP 应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。<br>
配置项：</p>
<pre><code>global #全局属性
    daemon  #以daemon方式在后台运行
    maxconn 256  #最大同时256连接
   

defaults #默认参数
    mode http  #http模式
    timeout connect 5000ms  #连接server端超时5s
    timeout client 50000ms  #客户端响应超时50s
    timeout server 50000ms  #server端响应超时50s
#绑定配置
listen rabbitmq_cluster 
    bind 0.0.0.0:5670
    #配置TCP模式
    mode tcp
    #加权轮询
    balance roundrobin
    #RabbitMQ集群节点配置
    server node1 0.0.0.0:5672 check inter 2000 rise 2 fall 3
    server node2 0.0.0.0:5673 check inter 2000 rise 2 fall 3
    server node3 0.0.0.0:5674 check inter 2000 rise 2 fall 3

#haproxy监控页面地址
listen monitor
    bind  0.0.0.0:8100
    mode http
    option httplog
    stats enable
    stats uri /stats
    stats refresh 5s

</code></pre>
<p>haproxy -f /usr/local/haproxy/conf/haproxy.cnf</p>
<h3 id="镜像队列">镜像队列</h3>
<p>交换器和绑定始终可视为在所有节点上，队列可以选择性的跨多个节点进行镜像。每个镜像队列由一个master和一个或者多个mirrors组成，主节点位于一个通常称为master的节点，每个队列都有自己的主节点。</p>
<h3 id="延迟队列">延迟队列</h3>
<p><img src="https://oscimg.oschina.net/oscnet/86897739832497bd1cfac14e629a3b3b7c8.jpg" alt="" loading="lazy"><br>
通过死信队列与消息的过期时间实现延时队列。<br>
生产者：</p>
<pre><code>$channel = $connection-&gt;channel();

$channel-&gt;exchange_declare('delay_exchange', 'direct',false,false,false);
$channel-&gt;exchange_declare('cache_exchange', 'direct',false,false,false);

$tale = new AMQPTable();
$tale-&gt;set('x-dead-letter-exchange', 'delay_exchange');
$tale-&gt;set('x-dead-letter-routing-key','delay_exchange');
$tale-&gt;set('x-message-ttl',10000);

$channel-&gt;queue_declare('cache_queue',false,true,false,false,false,$tale);
$channel-&gt;queue_bind('cache_queue', 'cache_exchange','cache_exchange');

$channel-&gt;queue_declare('delay_queue',false,true,false,false,false);
$channel-&gt;queue_bind('delay_queue', 'delay_exchange','delay_exchange');
$msg = new AMQPMessage('Hello World'.$argv[1],array(
    'expiration' =&gt; intval($argv[1]),
    'delivery_mode' =&gt; AMQPMessage::DELIVERY_MODE_PERSISTENT
));
$channel-&gt;basic_publish($msg,'cache_exchange','cache_exchange');
echo date('Y-m-d H:i:s').&quot; [x] Sent 'Hello World!' &quot;.PHP_EOL;
$channel-&gt;close();
$connection-&gt;close();
</code></pre>
<p>消费者:</p>
<pre><code>$channel = $connection-&gt;channel();
$channel-&gt;exchange_declare('delay_exchange', 'direct',false,false,false);
$channel-&gt;exchange_declare('cache_exchange', 'direct',false,false,false);
$channel-&gt;queue_declare('delay_queue',false,true,false,false,false);
$channel-&gt;queue_bind('delay_queue', 'delay_exchange','delay_exchange');

echo ' [*] Waiting for message. To exit press CTRL+C '.PHP_EOL;

$callback = function ($msg){
    echo date('Y-m-d H:i:s').&quot; [x] Received&quot;,$msg-&gt;body,PHP_EOL;

     $msg-&gt;delivery_info['channel']-&gt;basic_ack($msg-&gt;delivery_info['delivery_tag']);

};

//只有consumer已经处理并确认了上一条message时queue才分派新的message给它
$channel-&gt;basic_qos(null, 1, null);
$channel-&gt;basic_consume('delay_queue','',false,false,false,false,$callback);


while (count($channel-&gt;callbacks)) {
    $channel-&gt;wait();
}
$channel-&gt;close();
$connection-&gt;close();
</code></pre>
<h3 id="死信队列">死信队列</h3>
<p>一个消息在满足如下条件下，会进死信交换机，记住这里是交换机而不是队列，一个交换机可以对应很多队列。<br>
2.1 消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不会被再次放在队列里，被其他消费者使用。<br>
2.2 上面的消息的TTL到了，消息过期了。<br>
2.3 队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上。<br>
死信交换机就是普通的交换机，只是因为我们把过期的消息扔进去，所以叫死信交换机，并不是说死信交换机是某种特定的交换机</p>
<h3 id="优先级队列">优先级队列</h3>
<p>发布消息时可以设置优先级。</p>
<pre><code>$msg = new AMQPMessage(&quot;Hello World!&quot;, array(
 'delivery_mode' =&gt; 2,         // 设置消息持久化
 'priority' =&gt; 1,                   // 设置优先级
));
</code></pre>
<h3 id="使用插件的延时队列">使用插件的延时队列</h3>
<p>生产者：</p>
<pre><code>$conn = new AMQPConnection($connectConfig);
    $conn-&gt;connect();
    $channel = new AMQPChannel($conn);
    $exchange = new AMQPExchange($channel);
    $exchange-&gt;setName($params['exchangeName']);
    $exchange-&gt;setType('x-delayed-message');    //x-delayed-message类型
    /*RabbitMQ常用的Exchange Type有三种：fanout、direct、topic。

      fanout:把所有发送到该Exchange的消息投递到所有与它绑定的队列中。

      direct:把消息投递到那些binding key与routing key完全匹配的队列中。

      topic:将消息路由到binding key与routing key模式匹配的队列中。*/
    $exchange-&gt;setArgument('x-delayed-type','direct');
    $exchange-&gt;declareExchange();

    $channel-&gt;startTransaction();
    //RabbitMQ不容许声明2个相同名称、配置不同的Queue,否则报错
    $queue = new AMQPQueue($channel);
    $queue-&gt;setName($params['queueName']);
    $queue-&gt;setFlags(AMQP_DURABLE);
    $queue-&gt;declareQueue();

    //绑定队列和交换机
    $queue-&gt;bind($params['exchangeName'], $params['routeKey']);
    $channel-&gt;commitTransaction();

    for($i=1;$i &lt;= 5;$i++){
        //生成消息
        echo '发送时间：'.date(&quot;Y-m-d H:i:s&quot;, time()).PHP_EOL;
        echo 'i='.$i.'，延迟'.$i.'秒'.PHP_EOL;
        $message = json_encode(['order_id'=&gt;time(),'i'=&gt;$i]);
        $exchange-&gt;publish($message, $params['routeKey'], AMQP_NOPARAM, ['headers'=&gt;['x-delay'=&gt; 2000*$i]]);
        sleep(2);
    }
    $conn-&gt;disconnect();
</code></pre>
<p>消费者:</p>
<pre><code> $channel = $connection-&gt;channel();
    $queueName = 'delayed_queue_test';
    $callback = function ($msg) {
        echo ' [x] Received ', $msg-&gt;body, &quot;\n&quot;;
    };
    $channel-&gt;basic_consume($queueName, '', false, true, false, false, $callback);
    while ($channel-&gt;is_consuming()) {
        $channel-&gt;wait();
    }
</code></pre>
<h3 id="思维脑图">思维脑图</h3>
<p><a href="https://naotu.baidu.com/file/407c820a7e2f189bfc7b55150ca55ffb?token=29cc096245c90973">脑图</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机操作系统-进程管理]]></title>
        <id>https://miexxx.github.io/post/ji-suan-ji-cao-zuo-xi-tong-jin-cheng-guan-li/</id>
        <link href="https://miexxx.github.io/post/ji-suan-ji-cao-zuo-xi-tong-jin-cheng-guan-li/">
        </link>
        <updated>2020-03-16T06:42:09.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<hr>
<h1 id="进程与线程">进程与线程</h1>
<h2 id="进程是资源分配的基本单位">进程是资源分配的基本单位。</h2>
<p>进程控制块（PCB）创建进程，撤销进程的操作都是由PCB进行控制。<br>
下图显示了4个程序创建了4个进程，这4个进程能够并发的执行。<br>
<img src="https://camo.githubusercontent.com/23a2b15842e9766a36e7a18800540c290ad15388/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61366163326230382d333836312d346538352d626161382d3338323238376266656539662e706e67" alt="" loading="lazy"></p>
<h2 id="线程是独立调度的基本单位">线程是独立调度的基本单位。</h2>
<p>一个进程里可以有多个线程，他们共享资源，就像QQ与浏览器属于两个进程，但是浏览器进程中的包含事件响应线程，渲染线程等线程。</p>
<h2 id="区别">区别</h2>
<p>进程拥有资源，但是线程不拥有资源，但是线程可以访问进程的资源，统一进程中线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程的线程中会引起进程切换，进程的创建和销毁都需要系统进行分配和回收资源，如内存空间，I/O设备等，所付出的开销远大于线程的创建和销毁，线程之间的通信可以通过读取同一进程的数据进行通信，但是进程通信需要借助IPC。</p>
<hr>
<h1 id="进程状态的切换">进程状态的切换</h1>
<p>就绪状态(ready):等待被调度<br>
运行状态(running)<br>
阻塞状态：等待资源</p>
<p>只有就绪态和运行态可以相互转换，其他都是单向转换。就绪状态的进程通过调度算法从而获得cpu时间，转为运行状态，而运行状态的进程，在分配给它的CPU时间片用完之后就会转为就绪状态，等待下一次调度。<br>
阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括CPU时间，缺少CPU时间会从运行状态转换为就绪状态。</p>
<h1 id="进程调度算法">进程调度算法</h1>
<p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p>
<h2 id="批处理系统">批处理系统</h2>
<p>批处理系统里面没有太多的用户操作，在该系统中，调度算法是保证吞吐量和周转时间。</p>
<h3 id="先来先服务fcfs">先来先服务(FCFS)</h3>
<p>非抢占式的调度算法，安装请求的顺序进行调度，有利于长作业，不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<h3 id="短作业优先sjf">短作业优先(SJF)</h3>
<p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度，长作业可能饿死，处于一直等待短作业执行完毕状态。</p>
<h3 id="最短剩余时间优先srtn">最短剩余时间优先(SRTN)</h3>
<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度，当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较，如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
<h2 id="交互式系统">交互式系统</h2>
<p>交互式系统有大量的用户交换操作，在该系统中的调度算法的目标是快速地进行响应。</p>
<h3 id="时间片轮转">时间片轮转</h3>
<p>将所有就绪进程按FCFS的原则排成一个队列，每次调度时，把CPU时间分配给对首进程，该进程可以执行一个时间片，当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送到就绪队列的末尾，同时继续把CPU时间分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片大小有很大关系：<br>
因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。<br>
而如果时间片过长，那么实用性就不能够得到保证。</p>
<h3 id="优先级调度">优先级调度</h3>
<p>为每一个进程分配一个优先级，按优先级进行调度。<br>
为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<h3 id="多级反馈队列">多级反馈队列</h3>
<p>一个进程需要执行100个时间片，如果采用时间片轮转调度算法，那么需要交换100次。<br>
多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同。</p>
<h2 id="实时系统">实时系统</h2>
<p>实时系统要求一个请求在一个确定的时间内得到响应。<br>
分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<hr>
<h1 id="进程同步">进程同步</h1>
<h2 id="临界区">临界区</h2>
<p>对临界资源进行访问的那段代码称为临界区，为了互斥访问临界资源，每个进程进入临界区之前，需要先进行检查。</p>
<h2 id="同步与互斥">同步与互斥</h2>
<p>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。<br>
互斥：多个进程在同一时刻只有一个进程能进入临界区。</p>
<h2 id="信号量">信号量</h2>
<p>信号量是一个整形变量，可以对其执行down和up操作，也就是常见的P和V操作。<br>
down如果信号量大于0.执行-1操作，如果信号量等于0，进入睡眠，等待信号量大于0；<br>
up对信号量执行+1操作，唤醒睡眠的进程，让其完成down操作。<br>
down和up操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。<br>
如果信号量的取值只能为0和1，那么就成了互斥量，0表示临界区已经加锁，1表示临界区解锁。</p>
<hr>
<h1 id="进程通信">进程通信</h1>
<p>进程同步与进程通信很容易混淆，它们的区别在于：<br>
进程同步：控制多个进程按一定顺序执行；<br>
进程通信：进程间传输信息。<br>
进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<h2 id="管道">管道</h2>
<p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。<br>
只支持半双工通信（单向交替传输）；<br>
只能在父子进程或者兄弟进程中使用。</p>
<h2 id="fifo">FIFO</h2>
<p>也称为命名管道，去除看管道只能在父子进程中使用的限制。<br>
FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p>
<h2 id="消息队列">消息队列</h2>
<p>相比于 FIFO，消息队列具有以下优点：<br>
消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；<br>
避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；<br>
读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</p>
<h2 id="信号量-2">信号量</h2>
<p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p>
<h2 id="共享存储">共享存储</h2>
<p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。<br>
需要使用信号量用来同步对共享存储的访问。<br>
多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p>
<h2 id="套接字">套接字</h2>
<p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈Mysql索引]]></title>
        <id>https://miexxx.github.io/post/qian-tan-mysql-suo-yin/</id>
        <link href="https://miexxx.github.io/post/qian-tan-mysql-suo-yin/">
        </link>
        <updated>2020-03-09T12:31:46.000Z</updated>
        <content type="html"><![CDATA[<hr>
<h2 id="何为索引">何为索引</h2>
<p>索引其实就是一种优化查询的数据结构。比如mysql的索引就是使用B+树来实现的，而B+树就是一种数据结构，可以优化查询速度，所以可以利用索引来优化慢查询，索引的定义就是优化查询的数据结构。</p>
<hr>
<h2 id="有哪些可以优化查询的数据结构">有哪些可以优化查询的数据结构</h2>
<p>优化查询的数据结构有哈希表，完全平衡二叉树，B树，B+树。其中Mysql使用最多的是B+树。</p>
<hr>
<h2 id="hash表">hash表</h2>
<p>存储数据，需要先获取hashcode，再将数据存储到hashTable[hashcode],这种方式容易产生hash冲突，多个数据同时落到相同下标，可以采用hashTable[hashcode]存储的数据结构变化成链表，里面存储着这些公共hashcode的数据，这种方法叫做拉链法。<a href="https://www.cs.usfca.edu/~galles/visualization/OpenHash.html">实现过程</a><br>
优点: 适合查询单一数据，速度快。<br>
缺点：不适合查询范围数据，相当要遍历索引。</p>
<hr>
<h2 id="完全平衡二叉树">完全平衡二叉树</h2>
<p>每个节点最多只能有左右两个子节点，左子树 &lt; 节点 &lt; 右子数，左右子数的层级不能超过 1 层。<br>
<a href="https://link.zhihu.com/?target=https%3A//www.cs.usfca.edu/~galles/visualization/AVLtree.html">实现过程</a><br>
插入过程，判断当前数与根节点大小进行判断，如果小于根节点，向左子树继续寻找，否则向右子树继续寻找，直到叶子节点后，回溯判断，左右层级是否超过了1层，继续进行树的结构变化。<br>
优点：支持范围查询，因为二叉树是有序的。而且也可以提高查询效率，还是因为它是有序的，而且高度相比其它二叉树更平衡，通过二分法查询。<br>
缺点：二叉树这个定义的本身就限制了它，即一个节点只能有两个子节点，所以当插入的数据非常多时，树的深度就会非常高，树的深度非常高的话就会影响查询效率，所以没有使用二叉树来当索引的。</p>
<hr>
<h2 id="b树">B树</h2>
<p>简单介绍一下就是可以一个节点可以存储多个节点的搜索树。这样就没有了二叉树的两个节点的限制，同时带有有序的特点。所以图中有个参数：MAX.Degree,即一个节点存储的最大节点数，这里设置的是3，看得比较明显。这样的话一层就可以存储很多的数据了。<br>
<a href="https://link.zhihu.com/?target=https%3A//www.cs.usfca.edu/~galles/visualization/BTree.html">实现过程</a><br>
优点：它有二分查找可以快速定位数据的所在位置，而且每层可以存放大量数据，所以树的高度低。感觉还是很不错的。<br>
缺点：范围查询效率太低，因为比一个数据大的话，虽说肯定会在右子树，但是上层数据和其它子树的数据不好对比。</p>
<hr>
<h2 id="b树-2">B+树</h2>
<p><a href="https://link.zhihu.com/?target=https%3A//www.cs.usfca.edu/~galles/visualization/BPlusTree.html">实现过程</a><br>
我们对比一下B+树和B树，发现了什么？图中是有重复元素的，仔细一看，所有的非叶子节点都在叶子节点中出现了备份。也就是说，最下面的一层，也就是所有的叶子节点就包含了所有的数据。这就和前面的所有结构都不一样的地方了。然后，比起B树而言，叶子节点这层还有指向后面的指针，也就是多了指向。这就能很好地进行了范围查询，很好地解决了B树的问题。这样定位到数据后，直接在这层的指针遍历即可。<br>
经过上述的讨论，我总结了一下，衡量一种mysql索引好不好有三个原则：<br>
1.能不能快速定位到元素所在位置。<br>
2.能不能较好的进行范围查询。<br>
3.树的高度是低还是高。</p>
<hr>
<h2 id="局部性原理与磁盘预读">局部性原理与磁盘预读</h2>
<p>计算机科学中著名的局部性原理:当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
<p>所以操作系统为了提高效率，读取数据时往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，操作系统也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这里的-定长度叫做页，也就是操作系统操作磁盘时的基本单位。一般操作系统中 一页的大小是4Kb。</p>
<p>从上面的原理我们也能知道，固态硬盘比机械硬盘快的最根本最简单的原因就是:固态硬盘使用的电路进行读写，而机械硬盘使用的机械运动。<br>
其实不管是机械硬盘还是固态硬盘都是存储介质,真正控制读写的是操作系统。</p>
<p>这部分属于计算机原理和操作系统方面的知识，感觉理解一下还是很有必要的。</p>
<p>所以，回到我们的问题，B+树中一个节点到底存多少个元素合适?，其实也可以换个角度来思考B+树中一个节点到底多大合适?</p>
<p>答案是: B+树中一个节点为一页或页的倍数最为合适。因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出1页，造成资源的浪费;如果一个节点的大小大于1页，比如1.2页，那么读取这个节点的时候会读出2页，也会造成资源的浪费;所以为了不造成浪费，所以最后把一个节点的大小控制在1页、2页、3页、4页等倍数页大小最为合适。</p>
<p>那么，Mysql中B+树的一个节点大小为多大呢?<br>
这个问题的答案是“1页&quot;”，这里说的页&quot;是Mysq自定义的单位(其实和操作系统类似)，Mysql的Innodb引擎中一页的默认大小是16k (如果操作系统中-页大小是4k，那么Mysql中1 页=操作系统中4页)，可以使用命令SHOW GLOBAL STATUS like 'Innodb_ page size';查看。 并且还可以告诉你的是，一个节点为1页就够了。</p>
<p>为什么一个节点为一页（16kb）就够了呢？</p>
<p>先来看看mylsam和innodb使用B+树的情况：<br>
<img src="https://pic2.zhimg.com/80/v2-4229f0d89c874ff6c741e9bca99887c9_1440w.jpg" alt="" loading="lazy"><br>
通常我们认为B+树的非叶子节点不存储数据，只有叶子节点才存储数据。而B树的非叶子节点和叶子节点都会存储数据，这会导致非叶子节点存储的索引值更少，树的高度相对会比B+树高，平均的io效率会比较低，所以使用B+树作为索引的数据结构，再加上B+树的叶子节点之间会有指针相连，便于范围查询。上图的data区域两个存储引擎会有所不同，也就是聚族和非聚族索引的区别。后面详细讲解。</p>
<p>（这里说一下我对这里的为啥B树的高度相对B+树高的理解：就如上图所见，一个节点指的是<br>
<img src="https://pic4.zhimg.com/80/v2-1d06b9e7c77bf6fe72cd7a556ff42753_1440w.png" alt="" loading="lazy"></p>
<p>这才是一个节点，而不是单纯的15，或者加上旁边的一个指针。这样的话，前面已知一个节点是16kb大小，那么在这固定大小中，B树的非叶子节点还要存储数据，而B+树只存储值和指针。具体一点就是，假设数据大小2kb，值大小1kb,指针大小1kb。那么B树里只能有4个值，而B+树里则有8个值，这样的话，整个索引存储相同数量的值的话，B+树明显就比B树低，这样就提高了磁盘的io效率）</p>
<p>前面我们提到数据区域存储的东西，现在来进行详细解释：</p>
<p>myisam中，叶子节点的数据区域存储的是数据记录的地址。这也叫非聚族索引。</p>
<p>下面是主键索引：<br>
<img src="https://pic3.zhimg.com/80/v2-b26ee58c1e431ffda3645448858ee7b6_1440w.jpg" alt="" loading="lazy"></p>
<p>下面是辅助索引：<br>
<img src="https://pic3.zhimg.com/80/v2-ce65d7629ef49b53a23971e86c362f3a_1440w.jpg" alt="" loading="lazy"></p>
<p>从图中看得出来，叶子节点中只存储着地址（也就是此值对应的记录的所在地址），找到对应的地址，然后去地址中取出数据。并且主键索引和辅助索引并没有太多区别。</p>
<p>然后再来看innodb中的B+树：</p>
<p>下面是主键索引：<br>
<img src="https://pic1.zhimg.com/80/v2-c08615d9d603ab83532b325aa250789c_1440w.jpg" alt="" loading="lazy"></p>
<p>下面是辅助索引：<br>
<img src="https://pic1.zhimg.com/80/v2-b27e87b97d3c33d847ae97546ba2b1b0_1440w.jpg" alt="" loading="lazy"></p>
<p>innodb的主键索引和实际数据是绑定在一起的也就是说innodb的表一定要有一个主键索引，如果一个表没有手动创建一个主键索引，innodb会查看有没有唯一索引，如果有，则选用唯一索引作为主键，如果连唯一索引也没有，则会默认建立一个隐藏的主键索引（用户不可见）</p>
<p>另外，innodb的主键索引要比myisam的的主键索引查询效率较高（少一次磁盘io）,并且比辅助索引也要高很多。（这里不是很理解。。。。）</p>
<p>所以，我们在使用innodb作为存储引擎时，要注意：</p>
<p>1.手动建立一个主键索引</p>
<p>2.尽量利用主键索引进行查询</p>
<p>默默表示，看到这里对主键索引，辅助索引，聚族索引，非聚族索引有点理解不过来了。。。</p>
<p>后面慢慢缓冲。。</p>
<p>回到我们的问题:为什么一个节点为1页(16k) 就够了?</p>
<p>对着上面Mysql中Innodb中对B+树的实际应用(主要看主键索引)，我们可以发现，B+树中的一个节点存储的内容是:</p>
<p>非叶子节点 : 主键+指针</p>
<p>叶子节点 : 数据</p>
<p>那么，假设我们一行数据大小为1K,那么一页就能存16条数据，也就是一个叶子节点能存16条数据;</p>
<p>再看非叶子节点，假设主键ID为bigint类型, 那么长度为8B，指针大小在Innodb源码中为6B，-共就是14B,那么一页里就可以存储16K/14=1170个(主键+指针)，那么一颗高度 为2的B+树能存储的数据为:</p>
<p>1170<em>16=18720条，一 颗高度为3的B+树能存储的数据为: 1170</em>1170*16=21902400 (千万级条)。所以在InnoDB中B+树高度一般为1-3层， 它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO,所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。所以也就回答了我们的问题，1 页=16k这么设置是比较合适的，是适用大多数的企业的，当然这个值是可以修改的，所以也能根据业务的时间情况进行调整。</p>
<p>接着，我们来联系这次学到的索引底层原理再来看看我常常见到的最左前辍原则：</p>
<p>比如有下面这个B+树索引，我们建立了一个联合索引，顺序是emp_no,title,from_data.既然是联合索引，那么它们按理说应该是放在一起连续存放的。<br>
<img src="https://pic4.zhimg.com/80/v2-f9eca981e7b76e965036c8ff2a58767f_1440w.jpg" alt="" loading="lazy"></p>
<p>我们判断一 个查询条件能不能用到索引,我们要分析这个查询条件能不能利用某个索引缩小查询范围</p>
<p>对于select * from employees.titles where emp_ no = 1是能用到索引的，因为它能利用上面的索引缩小所有查询范围，首先和第一个节点&quot;4-r-01&quot;比较，1&lt;4, 所以可以直接确定结果在左子树，同理，依次按顺序进行比较，逐步可以缩小查询范围。</p>
<p>对于select * from employees. titles where title =‘1’是不能用到索引的，因为它不能用到上面的索引，和第一节点进行比较时，没有emp_ no这个字段的值，不能确定到底该去左子树还是右子树继续进行查询。</p>
<p>对于select * from employees.titles where title =‘1’and emp_ no = 1是能用到索引，按照我们的上面的分析,先用ttle='1 这个条件和第一个节点进行比较，是没有结果的，但是mysql会对这个sql进行优化，优化之后会将emp_ no=1这个条件放到第一位，从而可以利用索引。这里是使用了mysql的查询优化器。</p>
<p>Mysq总结</p>
<ol>
<li>
<p>B+树可以更好的结合磁盘IO原理提高查询效率</p>
</li>
<li>
<p>Innodb一 定要有主键，没有主键会以唯一索引为主键， 否则会建立一个隐藏主键</p>
</li>
<li>
<p>Innodb的数据是和主键索引存在一起的(数据在叶子节点中，MyISAM中的叶子节点存储的数据地址)</p>
</li>
</ol>
<p>4.建立索引时要考虑已有索引，一个SQL语句只会选择花费最低的一个索引执行</p>
<p>5.索引是一种有序的数据结构(B+树) ，一个节点可以存多个有序的元素，所以要利用好最左前缀原则<br>
6.真实场景中一颗B+树的高度通常为3</p>
]]></content>
    </entry>
</feed>