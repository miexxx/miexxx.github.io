<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Http | Great Wei</title>
<link rel="shortcut icon" href="https://miexxx.github.io/favicon.ico?v=1603337776623">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://miexxx.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Http | Great Wei - Atom Feed" href="https://miexxx.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="基础概念
uri
uri包好url 和urn

请求和响应报文
请求报文

响应报文

GET
获取资源
当前网络请求中，绝大部分使用的是GET方法。
HEAD
获取报文首部
和GET方法类似，但是不返回报文实体主体部分。
主要用于确认UR..." />
    <meta name="keywords" content="http" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://miexxx.github.io">
  <img class="avatar" src="https://miexxx.github.io/images/avatar.png?v=1603337776623" alt="">
  </a>
  <h1 class="site-title">
    Great Wei
  </h1>
  <p class="site-description">
    awsl
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/miexxx" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Http
            </h2>
            <div class="post-info">
              <span>
                2020-04-28
              </span>
              <span>
                13 min read
              </span>
              
                <a href="https://miexxx.github.io/tag/p4sg31lgg/" class="post-tag">
                  # http
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="基础概念">基础概念</h1>
<h2 id="uri">uri</h2>
<p>uri包好url 和urn<br>
<img src="https://camo.githubusercontent.com/b61eb498c8b9458916441d9341d3975b6e1134cf/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38343431623263342d646361372d346436622d386566622d6632326566636361663333312e706e67" alt="" loading="lazy"></p>
<h2 id="请求和响应报文">请求和响应报文</h2>
<h3 id="请求报文">请求报文</h3>
<figure data-type="image" tabindex="1"><img src="https://camo.githubusercontent.com/f48540e5efe054841d1aa19097666c4b35500c10/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f485454505f526571756573744d6573736167654578616d706c652e706e67" alt="" loading="lazy"></figure>
<h3 id="响应报文">响应报文</h3>
<figure data-type="image" tabindex="2"><img src="https://camo.githubusercontent.com/6ee5dc048dd39a9c4f9a180cee34c66b196a7c45/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f485454505f526573706f6e73654d6573736167654578616d706c652e706e67" alt="" loading="lazy"></figure>
<h3 id="get">GET</h3>
<p>获取资源<br>
当前网络请求中，绝大部分使用的是GET方法。</p>
<h3 id="head">HEAD</h3>
<p>获取报文首部<br>
和GET方法类似，但是不返回报文实体主体部分。<br>
主要用于确认URL的有效性以及资源更新的日期时间等。</p>
<h3 id="post">POST</h3>
<p>传输实体主体<br>
POST主要用来传输数据，而GET主要用来获取资源。</p>
<h3 id="put">PUT</h3>
<p>上传文件<br>
由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p>
<h3 id="patch">PATCH</h3>
<p>对资源进行部分修改<br>
PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p>
<h3 id="delete">DELETE</h3>
<p>删除文件<br>
与PUT功能相反，并且同样不带验证机制。</p>
<h3 id="options">OPTIONS</h3>
<p>查询支持的方法<br>
查询指定URL能够支持的方法</p>
<h3 id="connect">CONNECT</h3>
<p>要求在与代理服务器通信时简历隧道<br>
使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。<br>
CONNECT www.example.com:443 HTTP/1.1</p>
<h3 id="trace">TRACE</h3>
<p>服务器会将通信路径返回给客户端。<br>
发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。<br>
通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p>
<h2 id="http状态码">HTTP状态码</h2>
<p>服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>
<h3 id="1xx信息">1xx信息</h3>
<p>100 Continue:表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</p>
<h3 id="2xx成功">2xx成功</h3>
<p>200 ok<br>
204 No Content :请求已经成功处理，但是响应报文不包含实体的主题部分。<br>
一般只需要从客户端往服务器发送信息，而不逊要返回数据时使用。<br>
206 Partial Content：表示客户端进行了范围请求，响应报文报文包含 Content-Range 指定范围的实体内容。</p>
<h3 id="3xx重定向">3xx重定向</h3>
<p>301 Moved Permanmently : 永久重定向<br>
302 Found : 临时性重定向<br>
303 See Other： 和302有着相同的功能，但是303明确客户端应该采用GET方法获取资源<br>
304 Not Modified: 如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。<br>
307 Temporary Redirect: 临时重定向, 与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p>
<h3 id="4xx-客户端错误">4xx 客户端错误</h3>
<p>400 Bad Request ：请求报文中存在语法错误。<br>
401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。<br>
403 Forbidden ：请求被拒绝。<br>
404 Not Found</p>
<h3 id="5xx-服务端错误">5xx 服务端错误</h3>
<p>500 Internal Server Error ：服务器正在执行请求时发生错误。</p>
<p>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
<h2 id="http首部">HTTP首部</h2>
<h3 id="实体首部">实体首部</h3>
<h3 id="请求首部">请求首部</h3>
<h3 id="响应首部">响应首部</h3>
<h2 id="具体应用">具体应用</h2>
<h3 id="连接管理">连接管理</h3>
<h4 id="短连接与长连接">短连接与长连接</h4>
<p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p>
<p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p>
<p>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close；<br>
在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。</p>
<h4 id="流水线">流水线</h4>
<p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。<br>
流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p>
<h4 id="cookie">cookie</h4>
<p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p>
<h5 id="用途">用途</h5>
<p>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）<br>
个性化设置（如用户自定义设置、主题等）<br>
浏览器行为跟踪（如跟踪分析用户行为等）</p>
<h5 id="创建过程">创建过程</h5>
<p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p>
<p>HTTP/1.0 200 OK<br>
Content-type: text/html<br>
Set-Cookie: yummy_cookie=choco<br>
Set-Cookie: tasty_cookie=strawberry</p>
<p>[page content]<br>
客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p>
<p>GET /sample_page.html HTTP/1.1<br>
Host: www.example.org<br>
Cookie: yummy_cookie=choco; tasty_cookie=strawberry</p>
<h5 id="分类">分类</h5>
<p>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。<br>
持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。<br>
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</p>
<h5 id="作用域">作用域</h5>
<p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p>
<p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (&quot;/&quot;) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p>
<p>/docs<br>
/docs/Web/<br>
/docs/Web/HTTP</p>
<h5 id="javascript">JavaScript</h5>
<p>浏览器通过 document.cookie 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p>
<p>document.cookie = &quot;yummy_cookie=choco&quot;;<br>
document.cookie = &quot;tasty_cookie=strawberry&quot;;<br>
console.log(document.cookie);</p>
<h5 id="httponly">HttpOnly</h5>
<p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 document.cookie API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p>
<p>Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</p>
<h5 id="secure">Secure</h5>
<p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p>
<h5 id="session">Session</h5>
<p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<p>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；<br>
服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；<br>
服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；<br>
客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。<br>
应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<h5 id="浏览器禁用cookie">浏览器禁用Cookie</h5>
<p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p>
<h5 id="cookie-与-session-选择">Cookie 与 Session 选择</h5>
<p>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；<br>
Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；<br>
对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</p>
<h2 id="缓存">缓存</h2>
<h3 id="优点">优点</h3>
<p>缓解服务器压力；<br>
降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</p>
<h3 id="实现方法">实现方法</h3>
<p>让代理服务器进行缓存；<br>
让客户端浏览器进行缓存。</p>
<h3 id="cache-control">Cache-Control</h3>
<p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p>
<h4 id="禁止进行缓存">禁止进行缓存</h4>
<p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。<br>
Cache-Control: no-store</p>
<h4 id="强制确认缓存">强制确认缓存</h4>
<p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p>
<p>Cache-Control: no-cache</p>
<h4 id="私有缓存和公共缓存">私有缓存和公共缓存</h4>
<p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p>
<p>Cache-Control: private<br>
public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p>
<p>Cache-Control: public</p>
<h4 id="缓存过期机制">缓存过期机制</h4>
<p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p>
<p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p>
<p>Cache-Control: max-age=31536000<br>
Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>
<p>Expires: Wed, 04 Jul 2012 08:26:05 GMT<br>
在 HTTP/1.1 中，会优先处理 max-age 指令；<br>
在 HTTP/1.0 中，max-age 指令会被忽略掉。</p>
<h4 id="缓存验真">缓存验真</h4>
<p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 http://www.google.com/ 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p>
<p>ETag: &quot;82e22293907ce725faf67773957acd12&quot;<br>
可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p>
<p>If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot;<br>
Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p>
<p>Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT<br>
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</p>
<h2 id="内部协商">内部协商</h2>
<p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">基础概念</a>
<ul>
<li><a href="#uri">uri</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">请求和响应报文</a>
<ul>
<li><a href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">请求报文</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">响应报文</a></li>
<li><a href="#get">GET</a></li>
<li><a href="#head">HEAD</a></li>
<li><a href="#post">POST</a></li>
<li><a href="#put">PUT</a></li>
<li><a href="#patch">PATCH</a></li>
<li><a href="#delete">DELETE</a></li>
<li><a href="#options">OPTIONS</a></li>
<li><a href="#connect">CONNECT</a></li>
<li><a href="#trace">TRACE</a></li>
</ul>
</li>
<li><a href="#http%E7%8A%B6%E6%80%81%E7%A0%81">HTTP状态码</a>
<ul>
<li><a href="#1xx%E4%BF%A1%E6%81%AF">1xx信息</a></li>
<li><a href="#2xx%E6%88%90%E5%8A%9F">2xx成功</a></li>
<li><a href="#3xx%E9%87%8D%E5%AE%9A%E5%90%91">3xx重定向</a></li>
<li><a href="#4xx-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF">4xx 客户端错误</a></li>
<li><a href="#5xx-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%94%99%E8%AF%AF">5xx 服务端错误</a></li>
</ul>
</li>
<li><a href="#http%E9%A6%96%E9%83%A8">HTTP首部</a>
<ul>
<li><a href="#%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8">实体首部</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8">请求首部</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8">响应首部</a></li>
</ul>
</li>
<li><a href="#%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8">具体应用</a>
<ul>
<li><a href="#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86">连接管理</a>
<ul>
<li><a href="#%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%95%BF%E8%BF%9E%E6%8E%A5">短连接与长连接</a></li>
<li><a href="#%E6%B5%81%E6%B0%B4%E7%BA%BF">流水线</a></li>
<li><a href="#cookie">cookie</a>
<ul>
<li><a href="#%E7%94%A8%E9%80%94">用途</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B">创建过程</a></li>
<li><a href="#%E5%88%86%E7%B1%BB">分类</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F">作用域</a></li>
<li><a href="#javascript">JavaScript</a></li>
<li><a href="#httponly">HttpOnly</a></li>
<li><a href="#secure">Secure</a></li>
<li><a href="#session">Session</a></li>
<li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A6%81%E7%94%A8cookie">浏览器禁用Cookie</a></li>
<li><a href="#cookie-%E4%B8%8E-session-%E9%80%89%E6%8B%A9">Cookie 与 Session 选择</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a>
<ul>
<li><a href="#%E4%BC%98%E7%82%B9">优点</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">实现方法</a></li>
<li><a href="#cache-control">Cache-Control</a>
<ul>
<li><a href="#%E7%A6%81%E6%AD%A2%E8%BF%9B%E8%A1%8C%E7%BC%93%E5%AD%98">禁止进行缓存</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E7%A1%AE%E8%AE%A4%E7%BC%93%E5%AD%98">强制确认缓存</a></li>
<li><a href="#%E7%A7%81%E6%9C%89%E7%BC%93%E5%AD%98%E5%92%8C%E5%85%AC%E5%85%B1%E7%BC%93%E5%AD%98">私有缓存和公共缓存</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E6%9C%BA%E5%88%B6">缓存过期机制</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E9%AA%8C%E7%9C%9F">缓存验真</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%86%85%E9%83%A8%E5%8D%8F%E5%95%86">内部协商</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://miexxx.github.io/post/cr/">
              <h3 class="post-title">
                Crontab
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://miexxx.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
